#!/bin/bash

# color codes
RESTORE='\033[0m'
NC='\033[0m'
BLACK='\033[00;30m'
RED='\033[00;31m'
GREEN='\033[00;32m'
YELLOW='\033[00;33m'
BLUE='\033[00;34m'
PURPLE='\033[00;35m'
CYAN='\033[00;36m'
SEA="\\033[38;5;49m"
LIGHTGRAY='\033[00;37m'
LBLACK='\033[01;30m'
LRED='\033[01;31m'
LGREEN='\033[01;32m'
LYELLOW='\033[01;33m'
LBLUE='\033[01;34m'
LPURPLE='\033[01;35m'
LCYAN='\033[01;36m'
WHITE='\033[01;37m'
OVERWRITE='\e[1A\e[K'

#emoji codes
CHECK_MARK="${GREEN}\xE2\x9C\x94${NC}"
X_MARK="${RED}\xE2\x9C\x96${NC}"
PIN="${RED}\xF0\x9F\x93\x8C${NC}"
CLOCK="${GREEN}\xE2\x8C\x9B${NC}"
ARROW="${SEA}\xE2\x96\xB6${NC}"
BOOK="${RED}\xF0\x9F\x93\x8B${NC}"
HOT="${ORANGE}\xF0\x9F\x94\xA5${NC}"
WARNING="${RED}\xF0\x9F\x9A\xA8${NC}"
RIGHT_ANGLE="${GREEN}\xE2\x88\x9F${NC}"



set -e

# Load user configuration if it exists
if [ -f "$HOME/.dotfiles.conf" ]; then
  source "$HOME/.dotfiles.conf"
fi

# Configuration - can be overridden by environment variables or ~/.dotfiles.conf
DOTFILES_REPO="${DOTFILES_REPO:-git@github.com:blackbunt/dotfiles.git}"
DOTFILES_REPO_HTTPS="${DOTFILES_REPO_HTTPS:-https://github.com/blackbunt/dotfiles.git}"
DOTFILES_BRANCH="${DOTFILES_BRANCH:-main}"

# Locale settings (used by arch_based_setup)
LOCALE_LANG="${LOCALE_LANG:-en_GB.UTF-8}"
LOCALE_NUMERIC="${LOCALE_NUMERIC:-de_DE.UTF-8}"
LOCALE_TIME="${LOCALE_TIME:-de_DE.UTF-8}"
LOCALE_MONETARY="${LOCALE_MONETARY:-de_DE.UTF-8}"
LOCALE_PAPER="${LOCALE_PAPER:-de_DE.UTF-8}"
LOCALE_NAME="${LOCALE_NAME:-de_DE.UTF-8}"
LOCALE_ADDRESS="${LOCALE_ADDRESS:-de_DE.UTF-8}"
LOCALE_TELEPHONE="${LOCALE_TELEPHONE:-de_DE.UTF-8}"
LOCALE_MEASUREMENT="${LOCALE_MEASUREMENT:-de_DE.UTF-8}"
LOCALE_IDENTIFICATION="${LOCALE_IDENTIFICATION:-de_DE.UTF-8}"

# Optional settings
SKIP_BECOME_PASS="${SKIP_BECOME_PASS:-false}"
DEBUG="${DEBUG:-false}"
KEEP_LOG="${KEEP_LOG:-false}"
LASTPASS_EMAIL="${LASTPASS_EMAIL:-}"

# Paths
DOTFILES_LOG="$HOME/.dotfiles.log"
DOTFILES_DIR="$HOME/.dotfiles"
IS_FIRST_RUN="$HOME/.dotfiles_run"
# _header colorize the given argument with spacing
function __task {
  # if _task is called while a task was set, complete the previous
  if [[ $TASK != "" ]]; then
    printf "${OVERWRITE}${LGREEN}  [✓] ${LGREEN}${TASK}\n"
  fi
  # set new task title and print
  TASK=$1
  printf "${LBLUE}  [ ] ${TASK} \n${LRED}"
}

# _cmd performs commands with error checking
function _cmd {
  #create log if it doesn't exist
  if ! [[ -f $DOTFILES_LOG ]]; then
    touch $DOTFILES_LOG
  fi
  # empty log
  true > "$DOTFILES_LOG"
  # hide stdout, on error we print and exit
  if eval "$1" 1> /dev/null 2> "$DOTFILES_LOG"; then
    return 0 # success
  fi
  # read error from log and add spacing
  printf "${OVERWRITE}${LRED}  [X] ${TASK}${LRED}\n"
  while read -r line; do
    printf "      ${line}\n"
  done < "$DOTFILES_LOG"
  printf "\n"
  # remove log file
  rm "$DOTFILES_LOG"
  # exit installation
  exit 1
}

function _clear_task {
  TASK=""
}

function _task_done {
  printf "${OVERWRITE}${LGREEN}  [✓] ${LGREEN}${TASK}\n"
  _clear_task
}

function ubuntu_setup() {
  if ! dpkg -s ansible >/dev/null 2>&1; then
    __task "Installing Ansible"
    _cmd "sudo apt-get update"
    _cmd "sudo apt-get install -y software-properties-common"
    _cmd "sudo apt-add-repository -y ppa:ansible/ansible"
    _cmd "sudo apt-get update"
    _cmd "sudo apt-get install -y ansible"
    _cmd "sudo apt-get install python3-argcomplete"
    _cmd "sudo activate-global-python-argcomplete3"
  fi
  if ! dpkg -s python3 >/dev/null 2>&1; then
    __task "Installing Python3"
    _cmd "sudo apt-get install -y python3"
  fi

  local UBUNTU_MAJOR_VERSION
  UBUNTU_MAJOR_VERSION=$(echo "$VERSION_ID" | cut -d. -f1)
  if [ "$UBUNTU_MAJOR_VERSION" -le 22 ]; then
    if ! dpkg -s python3-pip >/dev/null 2>&1; then
      __task "Installing Python3 Pip"
      _cmd "sudo apt-get install -y python3-pip"
    fi
    if ! pip3 list | grep watchdog >/dev/null 2>&1; then
      __task "Installing Python3 Watchdog"
      _cmd "sudo apt-get install -y python3-watchdog"
    fi
  fi
}

function arch_based_setup() {
  if ! [ -x "$(command -v ansible)" ]; then
    __task "Installing Ansible"
    _cmd "sudo pacman -Sy --noconfirm"
    _cmd "sudo pacman -S --noconfirm ansible"
    _cmd "sudo pacman -S --noconfirm python-argcomplete"
  fi
  if ! pacman -Q python3 >/dev/null 2>&1; then
    __task "Installing Python3"
    _cmd "sudo pacman -S --noconfirm python3"
  fi
  if ! pacman -Q python-pip >/dev/null 2>&1; then
    __task "Installing Python3 Pip"
    _cmd "sudo pacman -S --noconfirm python-pip"
  fi
  if ! pip3 list | grep watchdog >/dev/null 2>&1; then
    __task "Installing Python3 Watchdog"
    _cmd "sudo pacman -S --noconfirm python-watchdog"
  fi

  if ! pacman -Q openssh >/dev/null 2>&1; then
    __task "Installing OpenSSH"
    _cmd "sudo pacman -S --noconfirm openssh"
  fi

  # Optional: Set locale if configured
  if [ -n "$LOCALE_LANG" ] && [ "$LOCALE_LANG" != "en_GB.UTF-8" ]; then
    __task "Setting Locale"
    _cmd "sudo localectl set-locale LANG=$LOCALE_LANG \
        LC_NUMERIC=$LOCALE_NUMERIC \
        LC_TIME=$LOCALE_TIME \
        LC_MONETARY=$LOCALE_MONETARY \
        LC_PAPER=$LOCALE_PAPER \
        LC_NAME=$LOCALE_NAME \
        LC_ADDRESS=$LOCALE_ADDRESS \
        LC_TELEPHONE=$LOCALE_TELEPHONE \
        LC_MEASUREMENT=$LOCALE_MEASUREMENT \
        LC_IDENTIFICATION=$LOCALE_IDENTIFICATION"
  fi
}

function macos_setup() {
  if ! [ -x "$(command -v brew)" ]; then
    __task "Installing Homebrew"
    _cmd "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
  fi
  if ! [ -x "$(command -v git)" ]; then
    __task "Installing Git"
    _cmd "brew install git"
  fi
  if ! [ -x "$(command -v ansible)" ]; then
    __task "Installing Ansible"
    _cmd "brew install ansible"
  fi
}

update_ansible_galaxy() {
  local os=$1
  local os_requirements=""
  __task "Updating Ansible Galaxy"
  if [ -f "$DOTFILES_DIR/requirements/$os.yml" ]; then
    __task "${OVERWRITE}Updating Ansible Galaxy with OS Config: $os"
    os_requirements="$DOTFILES_DIR/requirements/$os.yml"
  fi
  _cmd "ansible-galaxy install -r $DOTFILES_DIR/requirements/common.yml $os_requirements"
}

function confirmVaultAccess() {
  __task "Checking for LastPass CLI"
  if ! command -v lpass >/dev/null 2>&1; then
    printf "${OVERWRITE} ${RED}[X] Checking for LastPass CLI\n"
    printf " ${WARNING}${RED}   LastPass CLI is not installed.${NC}\n"
    exit 1
  fi
  
  local lpass_version
  lpass_version=$(lpass --version)
  printf "${OVERWRITE}${LGREEN}  [✓] LastPass CLI found: [$lpass_version]\n"
  
  __task "Checking LastPass authentication status"
  if lpass status >/dev/null 2>&1; then
    local logged_in_user
    logged_in_user=$(lpass status | grep -oP '(?<=Logged in as ).*(?=\.)' || echo "unknown")
    printf "${OVERWRITE}${LGREEN}  [✓] Already logged in as: ${logged_in_user}\n"
    return 0
  fi
  
  # Not logged in - try to login
  printf "${OVERWRITE}${LYELLOW}  [!] Not logged in to LastPass\n"
  
  if [ -z "$LASTPASS_EMAIL" ]; then
    printf "${RED}   ERROR: LASTPASS_EMAIL not set in ~/.dotfiles.conf${NC}\n"
    printf "${CYAN}   Please add: LASTPASS_EMAIL=\"your-email@example.com\" to ~/.dotfiles.conf${NC}\n"
    exit 1
  fi
  
  __task "Logging in to LastPass as: $LASTPASS_EMAIL"
  if lpass login "$LASTPASS_EMAIL"; then
    printf "${OVERWRITE}${LGREEN}  [✓] Successfully logged in to LastPass!\n"
    return 0
  else
    printf "${OVERWRITE}${LRED}  [X] Failed to login to LastPass\n"
    printf "   ${WARNING}${RED}  Please check your email and password.${NC}\n"
    exit 1
  fi
}

detect_os() {
  if [ -f /etc/os-release ]; then
    source /etc/os-release
    echo "$ID"
  else
    uname -s | tr '[:upper:]' '[:lower:]'
  fi
}

dotfiles_os=$(detect_os)
__task "Loading Setup for detected OS: $dotfiles_os"

case $dotfiles_os in
  ubuntu)
    ubuntu_setup
    ;;
  arch|endeavouros)
    arch_based_setup
    ;;
  darwin)
    macos_setup
    ;;
  *)
    __task "Unsupported OS"
    _cmd "echo 'Unsupported OS'"
    ;;
esac

# Clone or update repository
function clone_or_update_repo() {
  if ! [[ -d "$DOTFILES_DIR" ]]; then
    __task "Cloning repository"

    # Try SSH first (for private repos)
    if git clone --quiet --branch "$DOTFILES_BRANCH" "$DOTFILES_REPO" "$DOTFILES_DIR" 2>/dev/null; then
      _task_done
      return 0
    fi

    # Fallback to HTTPS if SSH fails
    __task "SSH clone failed, trying HTTPS"
    if git clone --quiet --branch "$DOTFILES_BRANCH" "$DOTFILES_REPO_HTTPS" "$DOTFILES_DIR" 2>/dev/null; then
      _task_done
      return 0
    fi

    # Both methods failed
    printf "${OVERWRITE}${LRED}  [X] Failed to clone repository\n"
    printf "      Tried SSH: $DOTFILES_REPO\n"
    printf "      Tried HTTPS: $DOTFILES_REPO_HTTPS\n"
    exit 1
  else
    __task "Updating repository"
    if git -C "$DOTFILES_DIR" pull --quiet 2>/dev/null; then
      _task_done
      return 0
    else
      printf "${OVERWRITE}${LYELLOW}  [!] Failed to update repository (continuing with local version)\n"
      return 0
    fi
  fi
}

clone_or_update_repo

pushd "$DOTFILES_DIR" > /dev/null 2>&1

confirmVaultAccess

# Create temporary password cache for ansible
ANSIBLE_BECOME_PASS_FILE="$HOME/.ansible_become_pass.$$"
trap 'rm -f "$ANSIBLE_BECOME_PASS_FILE"' EXIT

__task "Requesting sudo password for Ansible"
# Read password securely (no echo) and validate it
while true; do
  read -s -p "BECOME password: " BECOME_PASSWORD
  echo
  
  # Validate password by testing sudo
  if echo "$BECOME_PASSWORD" | sudo -S -v 2>/dev/null; then
    # Password is correct, save to temp file
    echo "$BECOME_PASSWORD" > "$ANSIBLE_BECOME_PASS_FILE"
    chmod 600 "$ANSIBLE_BECOME_PASS_FILE"
    _task_done
    break
  else
    printf "${LRED}  [X] Incorrect password, try again\n"
  fi
done

# Build ansible-playbook command with password file
ANSIBLE_CMD="ansible-playbook \"$DOTFILES_DIR/main.yml\""
ANSIBLE_CMD="$ANSIBLE_CMD --extra-vars \"ansible_become_pass={{ lookup('file', '$ANSIBLE_BECOME_PASS_FILE') }}\""

# Add any additional arguments passed to dotfiles script
if [ $# -gt 0 ]; then
  ANSIBLE_CMD="$ANSIBLE_CMD $*"
fi

# Execute ansible-playbook
if [ "$DEBUG" = "true" ]; then
  echo -e "${CYAN}Executing: $ANSIBLE_CMD${NC}"
fi

eval "$ANSIBLE_CMD"

popd > /dev/null 2>&1

if ! [[ -f "$IS_FIRST_RUN" ]]; then
  echo -e "${CHECK_MARK} ${GREEN}First run complete!${NC}"
  echo -e "${ARROW} ${CYAN}Please reboot your computer to complete the setup.${NC}"
  touch "$IS_FIRST_RUN"
fi

# vi:ft=sh:
